<===The command of find=== >
名称
	find - 在等级目录下寻找文件

概要
	find [-H] [-L] [-p] [-D debugopts] [_Olevel] [路径] [表达式]
描述
	这个手册记录的是GUN版本的find。根据优先级（参考OPERATIONS）GUN通过从左到右来评估给定的表达式来查找每个根文件，直到输出是已知的（对于操作来说左侧是true或者false），此时查找文件会移到下一个文件。如果你正在使用安全环境查找是很重要的（例如，你查找的是别人正在写的文件），你应该读find文件安全考虑这一章节，这被叫做查找文件和来到查找单元。那分文档包含了比这手册更多的细节和讨论，因此你可以发现更多有用的信息源。

操作
	-H -L和-P操作控制处理符号连接。以下这些命令行参数被视为要检查的文件或者目录的名称 直到以-开头的参数，或者( 或者 ！。该参数和以下任何参数被用作描述搜索内容的表达式。如果没有路径给出，则使用当前路径。如果没有表达式给出，-print会被使用（但是任何情况下你应该考虑使用-print0来代替）
	这个手册告诉关于操作表达式的列表。这些操作控制着查找的行为，但是在最后一个路径后立即指定。如果有的话，5个真正的操作 -H -L -P -D -O 必须在最后一个路径之前。 -- 可以被用作任何其余参数不是选项的信号（如果你使用一系列开始点的通配符，要确保所有启动位置 ./ 或者 / 是安全的）

	-P 从来不跟符号连接。这是自定义行为。当发现要查或者输出的信息是一个文件，文件是一个符号连接，使用的信息应从符号链接本身的属性中获取。

	-L 跟符号链接。当 find 的例子或者输出的信息是关于文件的，这些信息应当是取自文件链接点的属性，而不是链接本身（除非此链接是象征性的链接或者find不能去检查有链接点的文件）。此选项意味着 -noleaf。 如果你用在-P选项之后，-noleaf依然有效。在搜索过程中，如果-L处于有效中，find将不覆盖子目录，子目录的的点将通过符号链接被查找。
	当-L选项处于有效中，基于-type的操作相当于反对有符号链接的文件而不是链接本身（除非链接本身被破坏）。使用-L导致基于-lname和-ilname经常返回false。

	-H 除了处理命令行参数外，不遵循符号链接。当find的例子或者输出的信息是关于文件的。这些信息是文件属性链接的本身。有一个例外是当文件命令行是一个符号链接，链接可以被解决。有一个例外是当一个文件的特殊命令行是一个符号连接，此连接可以被解决。在这种情况下，这些被使用的信息是从其他连接文件点中提取（前提是连接点被允许）。如果文件连接指向不能被符号连接检查到，有关这些关于文件本身的信息将最为可靠的信息。如果-H是有效的而且其中任何一个特定的命令行是一个指向文件的符号连接，这些文件的目录将被检查(尽管 -maxdepth 0 会保护这些)

如果有比-H -L -P更多的向被指定，一个将会覆盖一个，最后一个命令将会起作用。虽然-P 是被默认的，但是-P 因改被考虑到被影响，除非 -H -L 没有被指定。

在运行命令本身的期间，GUN命令的find将会频繁的统计文件，在这中状态之前，一些查找已经开始。这些操作也会影响怎样处理这些操作。确切来说，这里有大量比较和当前正在考虑中的文件相反的文件命令列表的测试。每种情况，在命令行指定的文件将会被检查，其中一些特性将会被保存。事实上，如果被命名的文件影响符号连接，-P 将会起作用（或者指定-H 或者 -L），这些对比中使用的信息将会被从符号连接的特性中提取，否则，这些信息将会被从文件连接点的特性中提取。如果find不能跟随这些符号连接（例如无效的权限或者符号连接不存在文件），这些属于它本身自己的属性将会被使用。

当-H 或者 -L操作在起作用中， 一些符号连接类被列表化作为-newer 参数将会被引用，时间戳将会被从符号连接点获取。相同的想法可以应用-newerXY, -anewer 和-anewer。

这些-follow操作和-L的效果相同，尽管他产生的影响在他所呈现出来的点处（如果-L没有被使用，而-follow被用了，一些呈现在-follow命令之后将会被引用，之前的将不会被引用）

-D debug操作：
    输出诊断信息; 这可以帮助诊断为什么find 没有找到你想要的。这一列debug类表被逗号分开。通用的debug选项没有保证在发布的find单元框架之间。完整有效的dubug选项，可以看 find -D help的输出。有效的debug操作有：
	help  解释debug的选项
	tree  以最原始和最有效的树形式展示。
	stat  以stat 或 lstat调用系统的文件的检查信息。find命令尝试以最小的代价苏调用。
	opt   输出与最优表达树相关的诊断信息；参考 -O 的操作
	rates  输出预测成功过着失败的预测的指示的总和

-Oleval：
    使问题最优化。find重新排序测试执行速度以保护整体的效果；因此以边上的预测相互之间不能重排，在每一个最优的等级上的最优的形式如下：
	0    等于最优的第一级
	1    这是自定义的最优等级，和传统的行为相一致。表达式被重排以便基于文件名的文件（例如 -name 或者 -regex）首先被完成。
	2    任何 -type 或着 -xtype 的查找在基于文件名查找之后被完成，但是之前的任何查找都需要节点的信息。在一些现代版本的unix上，文件类型通过readdir()返回，在这些返回信息中比分析一份文件更快的是估算他的值。如果你使用-fstype FOO 去评判，指定的文件系统的类型FOO第一时间被查找，这些返回信息和-false是相同的。
	3    在这个最优等级上，基于优化查询的全部被启用。查找顺序被修目的是更快的查找被首先完成，比较慢的查找后完成。伴随的花费的代价是，返回信息根据是否可能成功进行更早或者更迟的评估。-o 是可能成功的信息而且更早的返回，而-a可能是失败的信息，比较迟的返回。
